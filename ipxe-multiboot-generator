#!/bin/bash
# Universal iPXE Multi-Boot Generator v3.1
# Hierarchical Sub-Menu System
# Linux Distributions | Windows PE | Bootloaders & Utilities | Debian Netinstaller

echo "Universal iPXE Multiboot Generator v3.1 - Sub-Menu Edition"
echo "=========================================================="
echo "Scanning for Linux, Windows PE, Bootloaders, and Utilities..."

IPXE_ROOT="/var/www/glitchlinux.wtf/ipxe"
WINPE_ROOT="$IPXE_ROOT/Windows-PE-ipxe"
BASE_URL="http://glitchlinux.wtf/ipxe"
MENU_FILE="$IPXE_ROOT/custom.ipxe"
BACKUP_FILE="$IPXE_ROOT/custom.ipxe.backup"

# Create backup
if [ -f "$MENU_FILE" ]; then
    cp "$MENU_FILE" "$BACKUP_FILE"
    echo "Backup created: $(basename $BACKUP_FILE)"
fi

# Fix permissions recursively
echo "Fixing permissions recursively..."
chown -R www-data:www-data "$IPXE_ROOT"
find "$IPXE_ROOT" -type d -exec chmod 755 {} \;
find "$IPXE_ROOT" -type f -exec chmod 644 {} \;

# Initialize counters and arrays
declare -a LINUX_DISTROS
declare -a LINUX_FAMILIES
declare -a LINUX_KERNELS
declare -a LINUX_INITRDS
declare -a LINUX_FILESYSTEMS
declare -a LINUX_BOOTPARAMS
linux_count=0

declare -a WINPE_SYSTEMS
declare -a WINPE_BCD
declare -a WINPE_SDI
declare -a WINPE_WIM
winpe_count=0

declare -a BOOTLOADER_ITEMS
declare -a BOOTLOADER_PATHS
declare -a BOOTLOADER_TYPES
bootloader_count=0

# Advanced distro detection
detect_distro_family() {
    local distro_name="$1"
    local distro_path="$2"
    local name_lower=$(echo "$distro_name" | tr '[:upper:]' '[:lower:]')
    
    if [[ "$name_lower" =~ (tails|whonix|kodachi|qubes) ]]; then
        echo "security"
    elif [[ "$name_lower" =~ (systemrescue|rescuezilla|clonezilla|gparted|boot.*repair|redo.*rescue|rescatux|hbcd) ]]; then
        echo "rescue"
    elif [[ "$name_lower" =~ (debian|ubuntu|mint|mx|antiX|sparky|parrot|kali|deepin|zorin|elementary|pop) ]] || 
         [ -f "$distro_path/live/filesystem.squashfs" ] || 
         [ -f "$distro_path/.disk/info" ]; then
        if [[ "$name_lower" =~ (ubuntu|mint|zorin|elementary|pop) ]] || 
           [ -d "$distro_path/casper" ]; then
            echo "ubuntu"
        else
            echo "debian"
        fi
    elif [[ "$name_lower" =~ (arch|manjaro|endeavour|garuda|blackarch) ]] || 
         [ -f "$distro_path/arch/boot/x86_64/vmlinuz-linux" ]; then
        echo "arch"
    elif [[ "$name_lower" =~ (fedora|rhel|centos|rocky|alma|opensuse) ]] || 
         [ -d "$distro_path/LiveOS" ]; then
        echo "redhat"
    elif [[ "$name_lower" =~ (gentoo|funtoo|calculate) ]]; then
        echo "gentoo"
    elif [[ "$name_lower" =~ (slackware|salix|vector) ]]; then
        echo "slackware"
    else
        echo "generic"
    fi
}

# Get boot parameters by family
get_boot_parameters() {
    local family="$1"
    local distro_name="$2"
    local name_lower=$(echo "$distro_name" | tr '[:upper:]' '[:lower:]')
    
    case "$family" in
        "security")
            if [[ "$name_lower" =~ tails ]]; then
                echo "boot=live config live-media=removable nopersistence noprompt timezone=Etc/UTC noautologin module=Tails vsyscall=none page_poison=1 init_on_alloc=1 init_on_free=1 mds=full,nosmt"
            else
                echo "boot=live components quiet splash"
            fi
            ;;
        "rescue")
            if [[ "$name_lower" =~ systemrescue ]]; then
                echo "archisobasedir=sysresccd copytoram"
            elif [[ "$name_lower" =~ gparted ]]; then
                echo "boot=live union=overlay username=user config components quiet splash"
            elif [[ "$name_lower" =~ clonezilla ]]; then
                echo "boot=live union=overlay username=user config components quiet splash ocs_live_run=\"ocs-live-general\""
            else
                echo "boot=live components quiet splash"
            fi
            ;;
        "ubuntu")
            echo "boot=casper maybe-ubiquity quiet splash"
            ;;
        "debian")
            echo "boot=live components quiet splash"
            ;;
        "arch")
            echo "archisobasedir=arch archisolabel=ARCH_$(date +%Y%m)"
            ;;
        "redhat")
            echo "rd.live.image quiet"
            ;;
        "gentoo")
            echo "dokeymap looptype=squashfs loop=/image.squashfs cdroot"
            ;;
        *)
            echo "boot=live components quiet splash"
            ;;
    esac
}

# Find kernel files
find_kernel_advanced() {
    local distro_path="$1"
    local search_paths=("$distro_path" "$distro_path/live" "$distro_path/casper" "$distro_path/boot" "$distro_path/arch/boot/x86_64" "$distro_path/isolinux" "$distro_path/syslinux")
    local kernel_patterns=("vmlinuz*" "bzImage*" "linux*" "kernel*" "vmlinux*")
    
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        for pattern in "${kernel_patterns[@]}"; do
            local found_kernel=$(find "$search_path" -maxdepth 1 -name "$pattern" -type f | head -1)
            if [ -n "$found_kernel" ]; then
                if [ "$search_path" = "$distro_path" ]; then
                    basename "$found_kernel"
                else
                    echo "$(basename "$search_path")/$(basename "$found_kernel")"
                fi
                return 0
            fi
        done
    done
    return 1
}

# Find initrd files
find_initrd_advanced() {
    local distro_path="$1"
    local search_paths=("$distro_path" "$distro_path/live" "$distro_path/casper" "$distro_path/boot" "$distro_path/arch/boot/x86_64" "$distro_path/isolinux" "$distro_path/syslinux")
    local initrd_patterns=("initrd.img*" "initrd*" "initramfs*" "initrfs*")
    
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        for pattern in "${initrd_patterns[@]}"; do
            local found_initrd=$(find "$search_path" -maxdepth 1 -name "$pattern" -type f | head -1)
            if [ -n "$found_initrd" ]; then
                if [ "$search_path" = "$distro_path" ]; then
                    basename "$found_initrd"
                else
                    echo "$(basename "$search_path")/$(basename "$found_initrd")"
                fi
                return 0
            fi
        done
    done
    return 1
}

# Find filesystem files
find_filesystem_advanced() {
    local distro_path="$1"
    local search_paths=("$distro_path/live" "$distro_path/casper" "$distro_path/LiveOS" "$distro_path")
    
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        for fs_file in filesystem.squashfs squashfs.img rootfs.img ext3fs.img; do
            if [ -f "$search_path/$fs_file" ]; then
                if [ "$search_path" = "$distro_path" ]; then
                    echo "$fs_file"
                else
                    echo "$(basename "$search_path")/$fs_file"
                fi
                return 0
            fi
        done
    done
    return 1
}

# Detect bootloader files (ISO, IMG, etc)
detect_bootloaders() {
    echo "Scanning for bootloaders and utility media..."
    
    local bootloader_extensions=("iso" "img" "bin" "vfd")
    local skip_dirs="(boot|EFI|isolinux|syslinux|Windows-PE-ipxe|live|casper|arch|sources)"
    
    for distro_dir in "$IPXE_ROOT"/*/; do
        [ ! -d "$distro_dir" ] && continue
        distro_name=$(basename "$distro_dir")
        
        # Skip known distro directories
        [[ "$distro_name" =~ $skip_dirs ]] && continue
        
        # Check if this is a Linux distro directory (has kernel/initrd)
        if find_kernel_advanced "$distro_dir" > /dev/null 2>&1; then
            continue  # Already processed as Linux distro
        fi
        
        # Look for bootloader files
        for ext in "${bootloader_extensions[@]}"; do
            while IFS= read -r -d '' file; do
                rel_path="${file#$IPXE_ROOT/}"
                item_name=$(basename "$file" | sed 's/\.[^.]*$//')
                file_type=$(echo "$ext" | tr '[:lower:]' '[:upper:]')
                
                BOOTLOADER_ITEMS+=("$item_name ($file_type)")
                BOOTLOADER_PATHS+=("$rel_path")
                BOOTLOADER_TYPES+=("$file_type")
                ((bootloader_count++))
                
                echo "  ✓ Found: $item_name ($file_type)"
            done < <(find "$distro_dir" -maxdepth 2 -name "*.$ext" -type f -print0)
        done
    done
}

# Windows PE detection
detect_winpe_systems() {
    echo "Scanning for Windows PE systems..."
    
    if [ ! -d "$WINPE_ROOT" ]; then
        echo "Windows PE directory not found: $WINPE_ROOT"
        return
    fi
    
    for winpe_dir in "$WINPE_ROOT"/*/; do
        [ ! -d "$winpe_dir" ] && continue
        winpe_name=$(basename "$winpe_dir")
        
        echo "Checking Windows PE: $winpe_name"
        
        local has_bcd=false
        local has_sdi=false  
        local has_wim=false
        local bcd_path=""
        local sdi_path=""
        local wim_path=""
        
        # Search for BCD file
        for bcd_loc in "boot/bcd" "boot/BCD" "efi/microsoft/boot/bcd" "Boot/BCD"; do
            if [ -f "$winpe_dir/$bcd_loc" ]; then
                has_bcd=true
                bcd_path="$bcd_loc"
                break
            fi
        done
        
        # Search for boot.sdi
        for sdi_loc in "boot/boot.sdi" "Boot/boot.sdi" "SDI/boot.sdi"; do
            if [ -f "$winpe_dir/$sdi_loc" ]; then
                has_sdi=true
                sdi_path="$sdi_loc"
                break
            fi
        done
        
        # Search for WIM file
        for wim_loc in "sources/boot.wim" "Sources/boot.wim" "WIM/boot.wim"; do
            if [ -f "$winpe_dir/$wim_loc" ]; then
                has_wim=true
                wim_path="$wim_loc"
                break
            fi
        done
        
        if [ "$has_bcd" = true ] && [ "$has_sdi" = true ] && [ "$has_wim" = true ]; then
            echo " ✓ Valid Windows PE: $winpe_name"
            WINPE_SYSTEMS+=("$winpe_name")
            WINPE_BCD+=("$bcd_path")
            WINPE_SDI+=("$sdi_path")
            WINPE_WIM+=("$wim_path")
            ((winpe_count++))
        else
            echo " ✗ Incomplete Windows PE: $winpe_name"
        fi
    done
}

# Linux distro detection and storage
detect_linux_distros() {
    echo "Scanning for Linux distributions..."
    
    for distro_dir in "$IPXE_ROOT"/*/; do
        [ ! -d "$distro_dir" ] && continue
        distro_name=$(basename "$distro_dir")
        
        # Skip system directories
        [[ "$distro_name" =~ ^(boot|EFI|isolinux|syslinux|MICROTECH-winPE|Windows-PE-ipxe)$ ]] && continue
        
        echo "Scanning: $distro_name"
        
        family=$(detect_distro_family "$distro_name" "$distro_dir")
        echo "  Detected family: $family"
        
        kernel_file=$(find_kernel_advanced "$distro_dir")
        initrd_file=$(find_initrd_advanced "$distro_dir")
        filesystem_file=$(find_filesystem_advanced "$distro_dir")
        
        if [ -n "$kernel_file" ] && [ -n "$initrd_file" ]; then
            echo "  ✓ Kernel: $kernel_file"
            echo "  ✓ InitRD: $initrd_file"
            [ -n "$filesystem_file" ] && echo "  ✓ Filesystem: $filesystem_file"
            
            boot_params=$(get_boot_parameters "$family" "$distro_name")
            
            LINUX_DISTROS+=("$distro_name")
            LINUX_FAMILIES+=("$family")
            LINUX_KERNELS+=("$kernel_file")
            LINUX_INITRDS+=("$initrd_file")
            LINUX_FILESYSTEMS+=("$filesystem_file")
            LINUX_BOOTPARAMS+=("$boot_params")
            ((linux_count++))
        else
            echo "  ✗ Missing required files"
        fi
    done
}

# Main menu generation starts here
cat > "$MENU_FILE" << 'MENU_START'
#!ipxe
# Universal Multi-Distro iPXE Menu v3.1
# Hierarchical Sub-Menu System
set base_url http://glitchlinux.wtf/ipxe

# Glitch Linux iPXE Theme
# Default text (white on black)
cpair --foreground 7 --background 0 0
# Normal UI text (green on black)
cpair --foreground 10 --background 0 1
# Highlighted text (white on green)
cpair --foreground 7 --background 10 2
# Separators (dim green on black)
cpair --foreground 2 --background 0 3
# Editable text (black on green)
cpair --foreground 0 --background 10 4
# Error messages (white on red)
cpair --foreground 7 --background 1 5
# Help URLs (green on black)
cpair --foreground 10 --background 0 6
# PXE selection (black on white)
cpair --foreground 0 --background 7 7

:start
clear menu_choice
menu GLITCH LINUX iPXE Multiboot
item --gap --
MENU_START

# Run detection functions
detect_winpe_systems
detect_linux_distros
detect_bootloaders

# Add menu items to main menu
if [ $linux_count -gt 0 ]; then
    echo "item linux_menu Linux Distributions ($linux_count)" >> "$MENU_FILE"
fi

if [ $winpe_count -gt 0 ]; then
    echo "item winpe_menu Windows PE Systems ($winpe_count)" >> "$MENU_FILE"
fi

if [ $bootloader_count -gt 0 ]; then
    echo "item bootloader_menu Bootloaders ($bootloader_count)" >> "$MENU_FILE"
fi

cat >> "$MENU_FILE" << 'MENU_MAIN'
item --gap --
item system_tools System Tools
item reboot_system Reboot
choose menu_choice || goto start
echo ${cls}
goto ${menu_choice}
MENU_MAIN

# ============================================
# LINUX DISTRIBUTIONS SUBMENU
# ============================================
if [ $linux_count -gt 0 ]; then
    cat >> "$MENU_FILE" << 'LINUX_SUBMENU_START'

:linux_menu
clear submenu_choice
menu Linux Distributions
LINUX_SUBMENU_START

    for ((i=0; i<linux_count; i++)); do
        distro_name="${LINUX_DISTROS[$i]}"
        item_base=$(echo "$distro_name" | tr '-' '_' | tr '.' '_' | tr ' ' '_')
        echo "item ${item_base}_boot $distro_name" >> "$MENU_FILE"
    done
    
    cat >> "$MENU_FILE" << 'LINUX_SUBMENU_END'
item --gap --
item back_to_main Back to Main Menu
choose submenu_choice || goto linux_menu
echo ${cls}
goto ${submenu_choice}
LINUX_SUBMENU_END

    # Generate boot entries for each Linux distro
    for ((i=0; i<linux_count; i++)); do
        distro_name="${LINUX_DISTROS[$i]}"
        family="${LINUX_FAMILIES[$i]}"
        kernel_file="${LINUX_KERNELS[$i]}"
        initrd_file="${LINUX_INITRDS[$i]}"
        filesystem_file="${LINUX_FILESYSTEMS[$i]}"
        boot_params="${LINUX_BOOTPARAMS[$i]}"
        item_base=$(echo "$distro_name" | tr '-' '_' | tr '.' '_' | tr ' ' '_')
        kernel_basename=$(basename "$kernel_file")

        cat >> "$MENU_FILE" << LINUX_BOOT_ENTRY

:${item_base}_boot
clear linux_boot_choice
menu $distro_name - Boot Options
item ${item_base}_fetch Network Fetch 
item ${item_base}_standard Standard Boot
LINUX_BOOT_ENTRY

        if [[ "$family" != "arch" ]]; then
            cat >> "$MENU_FILE" << LINUX_TORAM
item ${item_base}_toram Load to RAM
LINUX_TORAM
        fi

        cat >> "$MENU_FILE" << LINUX_DEBUG
item ${item_base}_debug Debug Mode
LINUX_DEBUG

        case "$family" in
            "security")
                echo "item ${item_base}_forensic Forensic Mode with No Swap" >> "$MENU_FILE"
                ;;
            "rescue")
                cat >> "$MENU_FILE" << LINUX_RESCUE
item ${item_base}_copytoram Copy to RAM
item ${item_base}_findroot Find Installed Systems
LINUX_RESCUE
                ;;
        esac

        cat >> "$MENU_FILE" << LINUX_NAV
item --gap --
item back_to_linux Back to Distributions
choose linux_boot_choice || goto ${item_base}_boot
echo \${cls}
goto \${linux_boot_choice}

:${item_base}_standard
echo Loading $distro_name (Standard)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
imgargs $kernel_basename $boot_params quiet splash ip=8.8.8.8
boot || goto ${item_base}_boot

:${item_base}_fetch
echo Loading $distro_name (Network Fetch)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
LINUX_NAV

        if [ -n "$filesystem_file" ]; then
            cat >> "$MENU_FILE" << LINUX_FETCH_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file ip=8.8.8.8
LINUX_FETCH_FS
        else
            cat >> "$MENU_FILE" << LINUX_FETCH_NOFS
imgargs $kernel_basename $boot_params ip=dhcp
LINUX_FETCH_NOFS
        fi

        cat >> "$MENU_FILE" << LINUX_FETCH_BOOT
boot || goto ${item_base}_boot
LINUX_FETCH_BOOT

        if [[ "$family" != "arch" ]]; then
            cat >> "$MENU_FILE" << LINUX_TORAM_BOOT

:${item_base}_toram
echo Loading $distro_name (Load to RAM)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
LINUX_TORAM_BOOT

            if [ -n "$filesystem_file" ]; then
                cat >> "$MENU_FILE" << LINUX_TORAM_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file toram ip=8.8.8.8
LINUX_TORAM_FS
            else
                cat >> "$MENU_FILE" << LINUX_TORAM_NOFS
imgargs $kernel_basename $boot_params toram ip=dhcp
LINUX_TORAM_NOFS
            fi

            cat >> "$MENU_FILE" << LINUX_TORAM_FINAL
boot || goto ${item_base}_boot
LINUX_TORAM_FINAL
        fi

        cat >> "$MENU_FILE" << LINUX_DEBUG_BOOT

:${item_base}_debug
echo Loading $distro_name (Debug Mode)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
LINUX_DEBUG_BOOT

        if [ -n "$filesystem_file" ]; then
            cat >> "$MENU_FILE" << LINUX_DEBUG_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file debug ip=8.8.8.8
LINUX_DEBUG_FS
        else
            cat >> "$MENU_FILE" << LINUX_DEBUG_NOFS
imgargs $kernel_basename $boot_params debug ip=dhcp
LINUX_DEBUG_NOFS
        fi

        cat >> "$MENU_FILE" << LINUX_DEBUG_FINAL
boot || goto ${item_base}_boot

:back_to_linux
goto linux_menu
LINUX_DEBUG_FINAL

        case "$family" in
            "security")
                cat >> "$MENU_FILE" << SECURITY_FORENSIC

:${item_base}_forensic
echo Loading $distro_name (Forensic Mode)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
SECURITY_FORENSIC

                if [ -n "$filesystem_file" ]; then
                    cat >> "$MENU_FILE" << SECURITY_FORENSIC_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file noswap ip=8.8.8.8
SECURITY_FORENSIC_FS
                else
                    cat >> "$MENU_FILE" << SECURITY_FORENSIC_NOFS
imgargs $kernel_basename $boot_params noswap ip=dhcp
SECURITY_FORENSIC_NOFS
                fi

                cat >> "$MENU_FILE" << SECURITY_FORENSIC_FINAL
boot || goto ${item_base}_boot
SECURITY_FORENSIC_FINAL
                ;;
            "rescue")
                cat >> "$MENU_FILE" << RESCUE_COPYTORAM

:${item_base}_copytoram
echo Loading $distro_name (Copy to RAM)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
RESCUE_COPYTORAM

                if [ -n "$filesystem_file" ]; then
                    cat >> "$MENU_FILE" << RESCUE_COPYTORAM_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file copytoram ip=8.8.8.8
RESCUE_COPYTORAM_FS
                else
                    cat >> "$MENU_FILE" << RESCUE_COPYTORAM_NOFS
imgargs $kernel_basename $boot_params copytoram ip=dhcp
RESCUE_COPYTORAM_NOFS
                fi

                cat >> "$MENU_FILE" << RESCUE_COPYTORAM_FINAL
boot || goto ${item_base}_boot

:${item_base}_findroot
echo Loading $distro_name (Find Root Systems)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
RESCUE_COPYTORAM_FINAL

                if [ -n "$filesystem_file" ]; then
                    cat >> "$MENU_FILE" << RESCUE_FINDROOT_FS
imgargs $kernel_basename $boot_params fetch=\${base_url}/$distro_name/$filesystem_file findroot ip=8.8.8.8
RESCUE_FINDROOT_FS
                else
                    cat >> "$MENU_FILE" << RESCUE_FINDROOT_NOFS
imgargs $kernel_basename $boot_params findroot ip=dhcp
RESCUE_FINDROOT_NOFS
                fi

                cat >> "$MENU_FILE" << RESCUE_FINDROOT_FINAL
boot || goto ${item_base}_boot
RESCUE_FINDROOT_FINAL
                ;;
        esac
    done
fi

# ============================================
# WINDOWS PE SUBMENU
# ============================================
if [ $winpe_count -gt 0 ]; then
    cat >> "$MENU_FILE" << 'WINPE_SUBMENU_START'

:winpe_menu
clear submenu_choice
menu Windows PE Systems
WINPE_SUBMENU_START

    for ((i=0; i<winpe_count; i++)); do
        winpe_name="${WINPE_SYSTEMS[$i]}"
        item_base=$(echo "$winpe_name" | tr '-' '_' | tr '.' '_' | tr ' ' '_')
        echo "item winpe_${item_base} $winpe_name" >> "$MENU_FILE"
    done
    
    cat >> "$MENU_FILE" << 'WINPE_SUBMENU_END'
item --gap --
item back_to_main Back to Main Menu
choose submenu_choice || goto winpe_menu
echo ${cls}
goto ${submenu_choice}
WINPE_SUBMENU_END

    # Generate boot entries for each Windows PE system
    for ((i=0; i<winpe_count; i++)); do
        winpe_name="${WINPE_SYSTEMS[$i]}"
        bcd_path="${WINPE_BCD[$i]}"
        sdi_path="${WINPE_SDI[$i]}"
        wim_path="${WINPE_WIM[$i]}"
        item_base=$(echo "$winpe_name" | tr '-' '_' | tr '.' '_' | tr ' ' '_')

        cat >> "$MENU_FILE" << WINPE_BOOT
:winpe_${item_base}
echo Loading $winpe_name...
echo Downloading Windows boot files via HTTP...
echo This may take some time for large WIM files...
echo
kernel \${base_url}/wimboot
initrd \${base_url}/Windows-PE-ipxe/${winpe_name}/${bcd_path} BCD
initrd \${base_url}/Windows-PE-ipxe/${winpe_name}/${sdi_path} boot.sdi
initrd \${base_url}/Windows-PE-ipxe/${winpe_name}/${wim_path} boot.wim
boot || goto winpe_menu

WINPE_BOOT
    done
fi

# ============================================
# BOOTLOADERS & UTILITIES SUBMENU
# ============================================
if [ $bootloader_count -gt 0 ]; then
    cat >> "$MENU_FILE" << 'BOOTLOADER_SUBMENU_START'

:bootloader_menu
clear submenu_choice
menu Bootloaders
BOOTLOADER_SUBMENU_START

    for ((i=0; i<bootloader_count; i++)); do
        bootloader_item="${BOOTLOADER_ITEMS[$i]}"
        item_base=$(echo "$bootloader_item" | tr '-' '_' | tr '.' '_' | tr ' ' '_' | sed 's/(.*)//')
        echo "item bootloader_${i} ${bootloader_item}" >> "$MENU_FILE"
    done
    
    cat >> "$MENU_FILE" << 'BOOTLOADER_SUBMENU_END'
item --gap --
item back_to_main Back to Main Menu
choose submenu_choice || goto bootloader_menu
echo ${cls}
goto ${submenu_choice}
BOOTLOADER_SUBMENU_END

    # Generate boot entries for each bootloader
    for ((i=0; i<bootloader_count; i++)); do
        bootloader_path="${BOOTLOADER_PATHS[$i]}"
        bootloader_type="${BOOTLOADER_TYPES[$i]}"
        bootloader_name=$(basename "${bootloader_path%.*}")

        cat >> "$MENU_FILE" << BOOTLOADER_BOOT
:bootloader_${i}
echo Loading ${bootloader_name} ($bootloader_type)...
sanboot --no-describe \${base_url}/${bootloader_path}
boot || goto bootloader_menu

BOOTLOADER_BOOT
    done
fi

# ============================================
# SYSTEM TOOLS SUBMENU
# ============================================
cat >> "$MENU_FILE" << 'SYSTEM_TOOLS'

:system_tools
clear tools_choice
menu System Tools
item boot_info System Information
item shell_access iPXE Shell
item local_boot Boot from Local Disk
item debian_13_2_0_netinst Debian 13.2.0 Netinstaller
item netboot_xyz Boot from netboot.xyz
item --gap --
item back_to_main Back to Main Menu
choose tools_choice || goto system_tools
echo ${cls}
goto ${tools_choice}

:boot_info
echo Universal iPXE Multiboot System v3.1
echo =====================================
echo Base URL: ${base_url}
echo
echo Available systems:
SYSTEM_TOOLS

if [ $linux_count -gt 0 ]; then
    echo "echo Linux Distributions: $linux_count" >> "$MENU_FILE"
fi
if [ $winpe_count -gt 0 ]; then
    echo "echo Windows PE Systems: $winpe_count" >> "$MENU_FILE"
fi
if [ $bootloader_count -gt 0 ]; then
    echo "echo Bootloaders: $bootloader_count" >> "$MENU_FILE"
fi

cat >> "$MENU_FILE" << 'SYSTEM_TOOLS_END'
echo
echo Features:
echo - Hierarchical sub-menu navigation
echo - Multiple boot modes per distribution
echo - Network filesystem loading via HTTP
echo - Memory optimization (ToRAM/CopyToRAM)
echo - Debug and forensic modes
echo - Windows PE wimboot support
echo - Debian netinstaller integration
echo
echo Press any key to return to menu...
prompt
goto start

:local_boot
echo Booting from local disk...
sanboot --no-describe --drive 0x80 || goto start

:debian_13_2_0_netinst
echo Loading Debian 13.2.0 Netinstall...
kernel ${base_url}/debian-testing-amd64-netinst/debian-installer/amd64/linux
initrd ${base_url}/debian-testing-amd64-netinst/debian-installer/amd64/initrd.gz
imgargs linux ip=dhcp
boot || goto system_tools

:netboot_xyz
chain --autofree http://boot.netboot.xyz

:back_to_main
goto start

:shell_access
echo Dropping to iPXE shell...
echo Type 'exit' to return to menu
shell
goto start

:reboot_system
echo Rebooting system...
reboot
SYSTEM_TOOLS_END

# Set final permissions
chown www-data:www-data "$MENU_FILE"
chmod 644 "$MENU_FILE"

# Summary report
echo ""
echo ""
echo "  Universal iPXE Multiboot Generator - COMPLETED" | borderize
echo ""
echo ""
