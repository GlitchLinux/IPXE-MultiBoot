#!/bin/bash
# Enhanced iPXE Multi-Boot Generator with Automatic Permission Fixing
# Automatically fixes permissions recursively every time it runs

echo "🔄 iPXE Multi-Boot Generator with Auto Permission Fix"
echo "===================================================="

# Update the script to include automatic permission fixing
cat > /usr/local/bin/ipxe-multiboot-generator << 'EOF'
#!/bin/bash
# Enhanced Dynamic Multi-Distro iPXE Menu Generator
# Includes automatic recursive permission fixing for ISO extractions

echo "🔄 Generating Dynamic Multi-Distro iPXE Menu (Enhanced + Auto-Fix)"
echo "================================================================="

# Configuration
IPXE_ROOT="/var/www/glitchlinux.wtf/ipxe"
BASE_URL="http://192.168.0.198/ipxe"
MENU_FILE="$IPXE_ROOT/custom.ipxe"
BACKUP_FILE="$IPXE_ROOT/custom.ipxe.backup"

# Check if running as root/sudo (needed for permission fixes)
if [[ $EUID -ne 0 ]]; then
    echo "⚠️  Running as regular user - some permission fixes may fail"
    echo "   For best results, run with: sudo ipxe-multiboot"
    echo "   Continuing anyway..."
    SUDO_PREFIX=""
else
    echo "✅ Running with root privileges - full permission fixing enabled"
    SUDO_PREFIX=""
fi

# Step 1: Fix permissions recursively FIRST
echo ""
echo "🔒 Step 1: Fixing permissions recursively for all iPXE files..."
echo "   This ensures extracted ISOs work properly for netboot"

# Function to fix permissions safely
fix_permissions() {
    local target_dir="$1"
    
    if [ ! -d "$target_dir" ]; then
        echo "   ❌ Directory not found: $target_dir"
        return 1
    fi
    
    echo "   📁 Fixing: $target_dir"
    
    # Set ownership to www-data:www-data
    ${SUDO_PREFIX}chown -R www-data:www-data "$target_dir" 2>/dev/null || {
        echo "   ⚠️  Could not change ownership (need sudo for extracted files)"
    }
    
    # Set proper directory permissions (755)
    ${SUDO_PREFIX}find "$target_dir" -type d -exec chmod 755 {} \; 2>/dev/null || {
        echo "   ⚠️  Could not fix directory permissions"
    }
    
    # Set proper file permissions (644)
    ${SUDO_PREFIX}find "$target_dir" -type f -exec chmod 644 {} \; 2>/dev/null || {
        echo "   ⚠️  Could not fix file permissions"
    }
    
    # Special check for critical boot files
    for file in "$target_dir"/**/vmlinuz* "$target_dir"/**/initrd* "$target_dir"/**/filesystem.squashfs; do
        if [ -f "$file" ]; then
            local current_perms=$(stat -c "%a" "$file" 2>/dev/null)
            if [ "$current_perms" = "600" ] || [ "$current_perms" = "700" ]; then
                echo "   🔧 Fixing restrictive permissions on $(basename "$file")"
                ${SUDO_PREFIX}chmod 644 "$file" 2>/dev/null
            fi
        fi
    done
}

# Fix permissions for entire iPXE directory
fix_permissions "$IPXE_ROOT"

# Also fix individual distro directories
for distro_dir in "$IPXE_ROOT"/*/; do
    [ ! -d "$distro_dir" ] && continue
    
    distro_name=$(basename "$distro_dir")
    [[ "$distro_name" =~ ^(boot|EFI|isolinux)$ ]] && continue
    
    # Check if this distro has permission issues
    local has_issues=false
    
    # Check for files with restrictive permissions
    if find "$distro_dir" -type f \( -perm 600 -o -perm 700 \) 2>/dev/null | grep -q .; then
        has_issues=true
    fi
    
    # Check for root ownership (common with sudo extractions)
    if find "$distro_dir" -user root 2>/dev/null | grep -q .; then
        has_issues=true
    fi
    
    if [ "$has_issues" = true ]; then
        echo "   🔧 Fixing permissions for $distro_name (found issues)"
        fix_permissions "$distro_dir"
    fi
done

echo "✅ Permission fixing completed"

# Step 2: Generate the menu (existing functionality)
echo ""
echo "🔍 Step 2: Scanning for distributions in $IPXE_ROOT..."

# Create backup of existing menu
if [ -f "$MENU_FILE" ]; then
    cp "$MENU_FILE" "$BACKUP_FILE"
    echo "💾 Backup created: $(basename $BACKUP_FILE)"
fi

# Start building the menu
cat > "$MENU_FILE" << 'MENU_START'
#!ipxe

# Enhanced Dynamic Multi-Distro iPXE Menu
# Auto-generated with subdirectory search and permission fixing

# Set variables
set base_url http://192.168.0.198/ipxe

:start
clear menu_choice
menu Glitch Linux Multi-Distro NetBoot
item --gap --             Available Distributions
MENU_START

# Function to detect distro type
detect_distro_type() {
    local distro_name="$1"
    local distro_path="$2"
    
    if [[ "$distro_name" =~ [Dd]ebian ]]; then
        echo "debian"
    elif [[ "$distro_name" =~ [Uu]buntu ]]; then
        echo "ubuntu"
    elif [[ "$distro_name" =~ [Mm][Xx] ]]; then
        echo "mx-linux"
    elif [[ "$distro_name" =~ [Kk]ali ]]; then
        echo "kali"
    elif [[ "$distro_name" =~ [Gg]litch ]] || [[ "$distro_name" =~ [Bb]onsai ]]; then
        echo "glitch"
    elif [[ "$distro_name" =~ [Aa]rch ]]; then
        echo "arch"
    elif [[ "$distro_name" =~ [Ff]edora ]]; then
        echo "fedora"
    elif [[ "$distro_name" =~ [Cc]ent[Oo][Ss] ]]; then
        echo "centos"
    elif [ -d "$distro_path/casper" ]; then
        echo "ubuntu-based"
    elif [ -d "$distro_path/live" ]; then
        echo "debian-based"
    else
        echo "generic"
    fi
}

# Function to get base boot parameters
get_base_boot_params() {
    local distro_type="$1"
    
    case "$distro_type" in
        "debian"|"debian-based"|"mx-linux"|"kali"|"glitch")
            echo "boot=live components"
            ;;
        "ubuntu"|"ubuntu-based")
            echo "boot=casper"
            ;;
        "arch")
            echo "archisobasedir=arch"
            ;;
        "fedora")
            echo "root=live:CDLABEL=Fedora-Live"
            ;;
        "centos")
            echo "root=live:CDLABEL=CentOS-Live"
            ;;
        *)
            echo "boot=live components"
            ;;
    esac
}

# Enhanced function to find kernel file in multiple locations
find_kernel() {
    local distro_path="$1"
    local found_kernel=""
    local found_path=""
    
    # Common kernel names
    local kernel_names=("vmlinuz" "vmlinux" "bzImage" "linux" "kernel")
    
    # Search locations in order of preference
    local search_paths=(
        "$distro_path"           # Root directory
        "$distro_path/live"      # Debian live systems
        "$distro_path/casper"    # Ubuntu live systems
        "$distro_path/boot"      # Generic boot directory
        "$distro_path/isolinux"  # Isolinux directory
        "$distro_path/syslinux"  # Syslinux directory
    )
    
    # Search each location
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        
        # Look for exact kernel names first
        for kernel in "${kernel_names[@]}"; do
            if [ -f "$search_path/$kernel" ]; then
                found_kernel="$kernel"
                found_path="$search_path"
                break 2
            fi
        done
        
        # Look for versioned kernels
        for kernel in "${kernel_names[@]}"; do
            local versioned=$(find "$search_path" -maxdepth 1 -name "${kernel}*" -type f | head -1)
            if [ -n "$versioned" ]; then
                found_kernel="$(basename "$versioned")"
                found_path="$search_path"
                break 2
            fi
        done
    done
    
    if [ -n "$found_kernel" ]; then
        # Return relative path from distro root
        if [ "$found_path" = "$distro_path" ]; then
            echo "$found_kernel"
        else
            local subdir=$(basename "$found_path")
            echo "$subdir/$found_kernel"
        fi
        return 0
    fi
    
    return 1
}

# Enhanced function to find initrd file in multiple locations
find_initrd() {
    local distro_path="$1"
    local found_initrd=""
    local found_path=""
    
    # Common initrd names
    local initrd_names=("initrd.img" "initrd.gz" "initramfs" "initrd")
    
    # Search locations (same as kernel)
    local search_paths=(
        "$distro_path"
        "$distro_path/live"
        "$distro_path/casper"
        "$distro_path/boot"
        "$distro_path/isolinux"
        "$distro_path/syslinux"
    )
    
    # Search each location
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        
        # Look for exact initrd names first
        for initrd in "${initrd_names[@]}"; do
            if [ -f "$search_path/$initrd" ]; then
                found_initrd="$initrd"
                found_path="$search_path"
                break 2
            fi
        done
        
        # Look for versioned initrds
        for initrd in "${initrd_names[@]}"; do
            local versioned=$(find "$search_path" -maxdepth 1 -name "${initrd}*" -type f | head -1)
            if [ -n "$versioned" ]; then
                found_initrd="$(basename "$versioned")"
                found_path="$search_path"
                break 2
            fi
        done
    done
    
    if [ -n "$found_initrd" ]; then
        # Return relative path from distro root
        if [ "$found_path" = "$distro_path" ]; then
            echo "$found_initrd"
        else
            local subdir=$(basename "$found_path")
            echo "$subdir/$found_initrd"
        fi
        return 0
    fi
    
    return 1
}

# Enhanced function to find filesystem file in multiple locations
find_filesystem() {
    local distro_path="$1"
    local found_fs=""
    local found_path=""
    
    # Common filesystem names
    local fs_names=("filesystem.squashfs" "linuxfs" "rootfs.img")
    
    # Search locations
    local search_paths=(
        "$distro_path"
        "$distro_path/live"
        "$distro_path/casper"
        "$distro_path/boot"
    )
    
    # Search each location
    for search_path in "${search_paths[@]}"; do
        [ ! -d "$search_path" ] && continue
        
        # Look for specific filesystem files
        for fs in "${fs_names[@]}"; do
            if [ -f "$search_path/$fs" ]; then
                found_fs="$fs"
                found_path="$search_path"
                break 2
            fi
        done
        
        # Look for any .squashfs files
        local squashfs=$(find "$search_path" -maxdepth 1 -name "*.squashfs" -type f | head -1)
        if [ -n "$squashfs" ]; then
            found_fs="$(basename "$squashfs")"
            found_path="$search_path"
            break
        fi
    done
    
    if [ -n "$found_fs" ]; then
        # Return relative path from distro root
        if [ "$found_path" = "$distro_path" ]; then
            echo "$found_fs"
        else
            local subdir=$(basename "$found_path")
            echo "$subdir/$found_fs"
        fi
        return 0
    fi
    
    return 1
}

# Function to verify file accessibility
verify_file_access() {
    local file_path="$1"
    local file_desc="$2"
    
    if [ -f "$file_path" ]; then
        local perms=$(stat -c "%a" "$file_path" 2>/dev/null)
        local owner=$(stat -c "%U:%G" "$file_path" 2>/dev/null)
        
        if [ "$perms" = "644" ] && [[ "$owner" =~ www-data ]]; then
            echo "    ✅ $file_desc: $perms $owner"
            return 0
        else
            echo "    ⚠️  $file_desc: $perms $owner (fixing...)"
            ${SUDO_PREFIX}chown www-data:www-data "$file_path" 2>/dev/null
            ${SUDO_PREFIX}chmod 644 "$file_path" 2>/dev/null
            return 1
        fi
    fi
    return 1
}

# Scan for distributions and create menu items
distro_count=0
distro_entries=""

for distro_dir in "$IPXE_ROOT"/*/; do
    [ ! -d "$distro_dir" ] && continue
    
    distro_name=$(basename "$distro_dir")
    [[ "$distro_name" =~ ^(boot|EFI|isolinux)$ ]] && continue
    
    echo "📁 Scanning: $distro_name"
    
    kernel_file=$(find_kernel "$distro_dir")
    initrd_file=$(find_initrd "$distro_dir")
    filesystem_file=$(find_filesystem "$distro_dir")
    
    if [ -n "$kernel_file" ] && [ -n "$initrd_file" ]; then
        echo "  ✅ Kernel: $kernel_file"
        echo "  ✅ InitRD: $initrd_file"
        [ -n "$filesystem_file" ] && echo "  ✅ Filesystem: $filesystem_file"
        
        # Verify file permissions
        echo "  🔒 Verifying permissions:"
        verify_file_access "$distro_dir/$kernel_file" "$(basename "$kernel_file")"
        verify_file_access "$distro_dir/$initrd_file" "$(basename "$initrd_file")"
        [ -n "$filesystem_file" ] && verify_file_access "$distro_dir/$filesystem_file" "$(basename "$filesystem_file")"
        
        distro_type=$(detect_distro_type "$distro_name" "$distro_dir")
        base_params=$(get_base_boot_params "$distro_type")
        
        echo "  🎯 Type: $distro_type"
        
        # Create clean item names
        item_base=$(echo "$distro_name" | tr '-' '_' | tr '.' '_')
        display_name="$distro_name"
        
        # Add submenu item
        cat >> "$MENU_FILE" << MENU_ITEM
item ${item_base}_menu          ${display_name} >
MENU_ITEM
        
        # Create boot entries for this distro with ALL options
        distro_entries="${distro_entries}

:${item_base}_menu
clear submenu_choice
menu $display_name Boot Options
item --gap --               Boot Methods
item ${item_base}_standard  Standard Boot
item ${item_base}_fetch     Network Fetch (Recommended)
item ${item_base}_toram     Load to RAM
item ${item_base}_debug     Debug Mode
item --gap --               Navigation
item back_to_main          Back to Main Menu
choose submenu_choice || goto start
echo \${cls}
goto \${submenu_choice}

:${item_base}_standard
echo Loading $display_name (Standard)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file
imgargs $(basename "$kernel_file") $base_params quiet splash ip=dhcp
boot || goto ${item_base}_menu

:${item_base}_fetch
echo Loading $display_name (Network Fetch)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file"

        # Add fetch parameter if filesystem exists
        if [ -n "$filesystem_file" ]; then
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params fetch=\${base_url}/$distro_name/$filesystem_file ip=dhcp"
        else
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params ip=dhcp"
        fi

        distro_entries="${distro_entries}
boot || goto ${item_base}_menu

:${item_base}_toram
echo Loading $display_name (Load to RAM)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file"

        if [ -n "$filesystem_file" ]; then
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params fetch=\${base_url}/$distro_name/$filesystem_file toram ip=dhcp"
        else
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params toram ip=dhcp"
        fi

        distro_entries="${distro_entries}
boot || goto ${item_base}_menu

:${item_base}_debug
echo Loading $display_name (Debug Mode)...
kernel \${base_url}/$distro_name/$kernel_file
initrd \${base_url}/$distro_name/$initrd_file"

        if [ -n "$filesystem_file" ]; then
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params fetch=\${base_url}/$distro_name/$filesystem_file debug ip=dhcp"
        else
            distro_entries="${distro_entries}
imgargs $(basename "$kernel_file") $base_params debug ip=dhcp"
        fi

        distro_entries="${distro_entries}
boot || goto ${item_base}_menu

:back_to_main
goto start
"
        
        ((distro_count++))
    else
        echo "  ❌ Missing files - Kernel: ${kernel_file:-NOT FOUND}, InitRD: ${initrd_file:-NOT FOUND}"
        
        # Show what subdirectories were found for debugging
        echo "  📂 Available subdirs:"
        for subdir in live casper boot isolinux syslinux; do
            if [ -d "$distro_dir/$subdir" ]; then
                echo "     ✅ $subdir/ ($(ls "$distro_dir/$subdir" | wc -l) files)"
            else
                echo "     ❌ $subdir/"
            fi
        done
    fi
done

# Add utilities section
cat >> "$MENU_FILE" << 'MENU_UTILS'
item --gap --             Utilities
item boot_info            Show Boot Information
item --gap --             System
item local_boot           Boot from Local Disk
item reboot_system        Reboot System
item shutdown_system      Shutdown System
choose menu_choice || goto start
echo ${cls}
goto ${menu_choice}

MENU_UTILS

# Add all distro boot entries
echo "$distro_entries" >> "$MENU_FILE"

# Add utility sections
cat >> "$MENU_FILE" << MENU_END
:boot_info
echo Boot Information:
echo Base URL: \${base_url}
echo Distributions found: $distro_count
echo
echo Available distributions:
MENU_END

# Add distro list to boot info
for distro_dir in "$IPXE_ROOT"/*/; do
    [ ! -d "$distro_dir" ] && continue
    distro_name=$(basename "$distro_dir")
    [[ "$distro_name" =~ ^(boot|EFI|isolinux)$ ]] && continue
    
    kernel_file=$(find_kernel "$distro_dir")
    initrd_file=$(find_initrd "$distro_dir")
    
    if [ -n "$kernel_file" ] && [ -n "$initrd_file" ]; then
        cat >> "$MENU_FILE" << DISTRO_INFO
echo   - $distro_name
DISTRO_INFO
    fi
done

cat >> "$MENU_FILE" << 'MENU_FINAL'
echo
echo Boot Methods Available:
echo   - Standard: Basic live boot
echo   - Network Fetch: Downloads filesystem (RECOMMENDED)
echo   - Load to RAM: Loads entire system to memory
echo   - Debug Mode: Verbose boot output
echo
echo Permissions: Auto-fixed for netboot compatibility
echo
echo Press any key to return to menu...
prompt
goto start

:local_boot
echo Booting from local disk...
sanboot --no-describe --drive 0x80 || goto start

:reboot_system
echo Rebooting system...
reboot

:shutdown_system
echo Shutting down system...
poweroff
MENU_FINAL

# Set proper permissions on menu file
${SUDO_PREFIX}chown www-data:www-data "$MENU_FILE"
${SUDO_PREFIX}chmod 644 "$MENU_FILE"

echo ""
echo "🎉 Enhanced Multi-Distro Menu Generated with Auto Permission Fix!"
echo ""
echo "📊 Summary:"
echo "   • Total distributions found: $distro_count"
echo "   • Permissions automatically fixed for all files"
echo "   • Enhanced search in: root/, live/, casper/, boot/, isolinux/"
echo "   • Each distro has 4 boot options"
echo ""
echo "📋 Found Distributions:"

for distro_dir in "$IPXE_ROOT"/*/; do
    [ ! -d "$distro_dir" ] && continue
    distro_name=$(basename "$distro_dir")
    [[ "$distro_name" =~ ^(boot|EFI|isolinux)$ ]] && continue
    
    kernel_file=$(find_kernel "$distro_dir")
    initrd_file=$(find_initrd "$distro_dir")
    
    if [ -n "$kernel_file" ] && [ -n "$initrd_file" ]; then
        distro_type=$(detect_distro_type "$distro_name" "$distro_dir")
        echo "   ✅ $distro_name ($distro_type) - 4 boot options"
    else
        echo "   ❌ $distro_name (missing files)"
    fi
done

echo ""
echo "🚀 Enhanced Features:"
echo "   ✅ Automatic recursive permission fixing"
echo "   ✅ Handles sudo-extracted ISOs automatically"
echo "   ✅ Searches live/, casper/, boot/ subdirectories"
echo "   ✅ No manual permission management needed!"
echo ""
echo "💡 Usage: Just extract ISOs and run 'sudo ipxe-multiboot'"
EOF

# Make executable
chmod +x /usr/local/bin/ipxe-multiboot-generator

echo "✅ Enhanced script with auto permission fixing installed!"
echo ""
echo "🔄 Testing the enhanced script..."
/usr/local/bin/ipxe-multiboot-generator

echo ""
echo "🎉 ENHANCED! Now automatically handles:"
echo "   🔒 Recursive permission fixing"
echo "   📁 Sudo-extracted ISO files"
echo "   🔧 www-data ownership setting"
echo "   📋 Permission verification per file"
echo ""
echo "💡 Usage:"
echo "   sudo mount -o loop distro.iso /mnt"
echo "   sudo cp -r /mnt/* /var/www/glitchlinux.wtf/ipxe/New-Distro/"
echo "   sudo ipxe-multiboot  # Automatically fixes permissions!"
echo ""
echo "🚀 No more permission issues with extracted ISOs!"
